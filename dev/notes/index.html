<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Notes about interpolation · Linear interpolators for Julia</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Linear interpolators for Julia</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../interpolation/">Linear interpolation</a></li><li><a class="tocitem" href="../library/">Reference</a></li><li class="is-active"><a class="tocitem" href>Notes about interpolation</a><ul class="internal"><li><a class="tocitem" href="#Definitions"><span>Definitions</span></a></li><li><a class="tocitem" href="#Kernel-support-and-neighbors-indices"><span>Kernel support and neighbors indices</span></a></li><li><a class="tocitem" href="#Clipping"><span>Clipping</span></a></li><li><a class="tocitem" href="#Efficient-computation-of-coefficients"><span>Efficient computation of coefficients</span></a></li><li><a class="tocitem" href="#Cubic-Interpolation"><span>Cubic Interpolation</span></a></li><li><a class="tocitem" href="#Resampling"><span>Resampling</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Notes about interpolation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Notes about interpolation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/emmt/LinearInterpolators.jl/blob/master/docs/src/notes.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Notes-about-interpolation"><a class="docs-heading-anchor" href="#Notes-about-interpolation">Notes about interpolation</a><a id="Notes-about-interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Notes-about-interpolation" title="Permalink"></a></h1><h2 id="Definitions"><a class="docs-heading-anchor" href="#Definitions">Definitions</a><a id="Definitions-1"></a><a class="docs-heading-anchor-permalink" href="#Definitions" title="Permalink"></a></h2><h3 id="Notations"><a class="docs-heading-anchor" href="#Notations">Notations</a><a id="Notations-1"></a><a class="docs-heading-anchor-permalink" href="#Notations" title="Permalink"></a></h3><p>Round parenthesis, as in <code>f(x)</code>, denote a continuous function (<code>x</code> is a real number), square brakets, as in <code>a[k]</code>, denote a sampled function (<code>k ∈ ℤ</code> is an integer number).</p><h3 id="Interpolation"><a class="docs-heading-anchor" href="#Interpolation">Interpolation</a><a id="Interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolation" title="Permalink"></a></h3><p>Interpolation amounts to convolving with a kernel <code>ker(x)</code>:</p><pre><code class="nohighlight hljs">f(x) = sum_k a[clip(k)]*ker(x - k)</code></pre><p>where <code>clip(k)</code> imposes the boundary conditions and makes sure that the resulting index is within the bounds of array <code>a</code>.</p><p>It can be seen that interpolation acts as a linear filter.  Finite impulse response (FIR) filters have a finite support.  By convention we use centered kernels whose support is <code>(-s/2,+s/2)</code> with <code>s</code>the width of the support. Infinite impulse response (IIR) filters have an infinite support.</p><h3 id="Floor-and-ceil-functions"><a class="docs-heading-anchor" href="#Floor-and-ceil-functions">Floor and ceil functions</a><a id="Floor-and-ceil-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Floor-and-ceil-functions" title="Permalink"></a></h3><p>Definitions of the <code>floor()</code> and <code>ceil()</code> functions (<code>∀ x ∈ ℝ</code>):</p><pre><code class="nohighlight hljs">floor(x) = ⌊x⌋ = k ∈ ℤ   s.x.  k ≤ x &lt; k+1
 ceil(x) = ⌈x⌉ = k ∈ ℤ   s.x.  k-1 &lt; x ≤ k</code></pre><p>As a consequence (<code>∀ x ∈ ℝ</code> and <code>∀ k ∈ ℤ</code>):</p><pre><code class="nohighlight hljs">floor(x) ≤ k   &lt;=&gt;   x &lt; k+1       (1a)
floor(x) &lt; k   &lt;=&gt;   x &lt; k         (1b)

floor(x) ≥ k   &lt;=&gt;   x ≥ k         (1c)
floor(x) &gt; k   &lt;=&gt;   x ≥ k+1       (1d)

ceil(x) ≤ k    &lt;=&gt;   x ≤ k         (2a)
ceil(x) &lt; k    &lt;=&gt;   x ≤ k-1       (2b)

ceil(x) ≥ k    &lt;=&gt;   x &gt; k-1       (2c)
ceil(x) &gt; k    &lt;=&gt;   x &gt; k         (2d)</code></pre><h2 id="Kernel-support-and-neighbors-indices"><a class="docs-heading-anchor" href="#Kernel-support-and-neighbors-indices">Kernel support and neighbors indices</a><a id="Kernel-support-and-neighbors-indices-1"></a><a class="docs-heading-anchor-permalink" href="#Kernel-support-and-neighbors-indices" title="Permalink"></a></h2><h3 id="General-support"><a class="docs-heading-anchor" href="#General-support">General support</a><a id="General-support-1"></a><a class="docs-heading-anchor-permalink" href="#General-support" title="Permalink"></a></h3><p>Let <code>(a,b)</code> with <code>a &lt; b</code> be the support of the kernel.  We assume that the support size is strict, i.e. <code>ker(x) = 0</code> if <code>x ≤ a</code> or <code>x ≥ b</code>.  Thus, for a given <code>x</code>, the <em>neighbors</em> indices <code>k</code> to take into account in the interpolation formula are such that:</p><pre><code class="nohighlight hljs">a &lt; x - k &lt; b     &lt;=&gt;    x - b &lt; k &lt; x - a</code></pre><p>because outside this range, <code>ker(x - k) = 0</code>.</p><p>Using the equivalences <code>(1b)</code> and <code>(2d)</code>, the <em>neighbors</em> indices <code>k</code> are those for which:</p><pre><code class="nohighlight hljs">floor(x - b) &lt; k &lt; ceil(x - a)</code></pre><p>holds.  Equivalently:</p><pre><code class="nohighlight hljs">floor(x - b + 1) ≤ k ≤ ceil(x - a - 1)</code></pre><p>The first index to take into account is <code>kfirst = floor(x - b + 1)</code> and the last index to take into account is <code>klast = ceil(x - a - 1)</code>.</p><h3 id="Symmetric-integer-support"><a class="docs-heading-anchor" href="#Symmetric-integer-support">Symmetric integer support</a><a id="Symmetric-integer-support-1"></a><a class="docs-heading-anchor-permalink" href="#Symmetric-integer-support" title="Permalink"></a></h3><p>Let <code>s = |b - a|</code> denotes the width of the support of the kernel.  We now assume that the support size is integer (<code>s ∈ ℕ</code>), symmetric (<code>a = -s/2</code> and <code>b = +s/2</code>), and strict (<code>ker(x) = 0</code> if <code>|x| ≥ s/2</code>).  Thus, for a given <code>x</code>, the <em>neighbors</em> indices <code>k</code> to take into account are such that:</p><pre><code class="nohighlight hljs">|x - k| &lt; s/2   &lt;=&gt;   x - s/2 &lt; k &lt; x + s/2
                &lt;=&gt;   floor(x - s/2 + 1) ≤ k ≤ ceil(x + s/2 - 1)</code></pre><p>The number of indices in the above range is equal to <code>s</code> unless <code>x</code> is integer while <code>s</code> is even or <code>x</code> is half-integer while <code>s</code> is odd.  For these specific cases, there are <code>s - 1</code> indices in the range.  However, always having the same number (<code>s</code>) of indices to consider yields code easier to write and optimize. We therefore choose that the first index <code>k1</code> and last index <code>ks</code> to take into account are either:</p><ul><li><p><code>k1 = floor(x - s/2 + 1)</code> and <code>ks = k1 + s - 1</code>;</p></li><li><p>or <code>ks = ceil(x + s/2 - 1)</code> and <code>k1 = ks - s + 1</code>.</p></li></ul><p>For the specific values of <code>x</code> aforementioned, one of <code>ker(x - k1) = 0</code> or <code>ker(x - ks) = 0</code> holds.  For other values of <code>x</code>, the two choices are equivalent.</p><p>In what follows, we choose to define the first index (before clipping) by:</p><pre><code class="nohighlight hljs">k1 = k0 + 1</code></pre><p>with</p><pre><code class="nohighlight hljs">k0 = floor(x - s/2)</code></pre><p>and all indices to consider are:</p><pre><code class="nohighlight hljs">k = k0 + 1, k0 + 2, ..., k0 + s</code></pre><h2 id="Clipping"><a class="docs-heading-anchor" href="#Clipping">Clipping</a><a id="Clipping-1"></a><a class="docs-heading-anchor-permalink" href="#Clipping" title="Permalink"></a></h2><p>Now we have the constraint that: <code>kmin ≤ k ≤ kmax</code>.  If we apply a <em>&quot;nearest bound&quot;</em> condition, then:</p><ul><li><p>if <code>ks = k0 + s ≤ kmin</code>, then <strong>all</strong> infices <code>k</code> are clipped to <code>kmin</code>; using the fact that <code>s</code> is integer and equivalence <code>(1a)</code>, this occurs whenever:</p><pre><code class="nohighlight hljs">      kmin ≥ k0 + s = floor(x - s/2) + s = floor(x + s/2)
&lt;=&gt;   x &lt; kmin - s/2 + 1</code></pre></li><li><p>if <code>kmax ≤ k1 = k0 + 1</code>, then <strong>all</strong> indices <code>k</code> are clipped to <code>kmax</code>; using equivalence <code>(1c)</code>, this occurs whenever:</p><pre><code class="nohighlight hljs">      kmax ≤ k0 + 1 = floor(x - s/2 + 1)
&lt;=&gt;   x ≥ kmax + s/2 - 1</code></pre></li></ul><p>These cases have to be considered before computing <code>k0 = (int)floor(x - s/2)</code> not only for optimization reasons but also because <code>floor(...)</code> may be beyond the limits of a numerical integer.</p><p>The most simple case is when all considered indices are within the bounds which, using equivalences <code>(1a)</code> and <code>(1c)</code>, implies:</p><pre><code class="nohighlight hljs">      kmin ≤ k0 + 1   and   k0 + s ≤ kmax
&lt;=&gt;   kmin + s/2 - 1 ≤ x &lt; kmax - s/2 + 1</code></pre><h2 id="Efficient-computation-of-coefficients"><a class="docs-heading-anchor" href="#Efficient-computation-of-coefficients">Efficient computation of coefficients</a><a id="Efficient-computation-of-coefficients-1"></a><a class="docs-heading-anchor-permalink" href="#Efficient-computation-of-coefficients" title="Permalink"></a></h2><p>For a given value of <code>x</code> the coefficients of the interpolation are given by:</p><pre><code class="nohighlight hljs">w[i] = ker(x - k0 - i)</code></pre><p>with <code>k0 = floor(x - s/2)</code> and for <code>i = 1, 2, ..., s</code>.</p><p>Note that there must be no clipping of the indices here, clipping is only for indexing the interpolated array and depends on the boundary conditions.</p><p>Many interpolation kernels (see below) are <em>splines</em> which are piecewise polynomials defined over sub-intervals of size 1.  That is:</p><pre><code class="nohighlight hljs">ker(x) = h[1](x)    for -s/2 ≤ x ≤ 1 - s/2
         h[2](x)    for 1 - s/2 ≤ x ≤ 2 - s/2
         ...
         h[j](x)    for j - 1 - s/2 ≤ x ≤ j - s/2
         ...
         h[s](x)    for s/2 - 1 ≤ x ≤ s/2</code></pre><p>Hence</p><pre><code class="nohighlight hljs">w[i] = ker(x - k0 - i) = h[s + 1 - i](x - k0 - i)</code></pre><p>In Julia implementation the interpolation coefficients are computed by the <code>getweights()</code> method specialized for each type of kernel an called as:</p><pre><code class="language-julia hljs">getweights(ker, t) -&gt; w1, w2, ..., wS</code></pre><p>to get the <code>S</code> interpolation weights for a given offset <code>t</code> computed as:</p><pre><code class="nohighlight hljs">t = x - floor(x)        if s is even
    x - round(x)        if s is odd</code></pre><p>Thus <code>t ∈ [0,1]</code> if <code>S</code> is even or or for <code>t ∈ [-1/2,+1/2]</code> if <code>S</code> is odd.</p><p>There are 2 cases depending on the parity of <code>s</code>:</p><ul><li><p>If <code>s</code> is even, then <code>k0 = floor(x - s/2) = floor(x) - s/2</code> hence <code>t = x - floor(x) = x - k0 - s/2</code>.</p></li><li><p>If <code>s</code> is odd, then <code>k0 = floor(x - s/2) = floor(x + 1/2) - (s + 1)/2</code> <code>round(x) = floor(x + 1/2) = k0 + (s + 1)/2</code> and <code>t = x - round(x) = x - k0 - (s + 1)/2</code>.</p></li></ul><p>Therefore the argument of <code>h[s + 1 - i](...)</code> is:</p><pre><code class="nohighlight hljs">x - k0 - i = t + s/2 - i          if s is even
             t + (s + 1)/2 - i    if s is odd</code></pre><p>or:</p><pre><code class="nohighlight hljs">x - k0 - i = t + ⌊(s + 1)/2⌋ - i</code></pre><p>whatever the parity of <code>s</code>.</p><h2 id="Cubic-Interpolation"><a class="docs-heading-anchor" href="#Cubic-Interpolation">Cubic Interpolation</a><a id="Cubic-Interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Cubic-Interpolation" title="Permalink"></a></h2><p>Keys&#39;s cubic interpolation kernels are given by:</p><pre><code class="nohighlight hljs">ker(x) = (a+2)*|x|^3 - (a+3)*|x|^2 + 1          for |x| ≤ 1
       = a*|x|^3 - 5*a*|x|^2 + 8*a*|x| - 4*a    for 1 ≤ |x| ≤ 2
       = 0                                      else</code></pre><p>Mitchell and Netravali family of piecewise cubic filters (which depend on 2 parameters, <code>b</code> and <code>c</code>) are given by:</p><pre><code class="nohighlight hljs">ker(x) = (1/6)*((12 - 9*b - 6*c)*|x|^3
         + (-18 + 12*b + 6*c)*|x|^2 + (6 - 2*B))        for |x| ≤ 1
       = (1/6)*((-b - 6*c)*|x|^3 + (6*b + 30*c)*|x|^2
         + (-12*b - 48*c)*|x| + (8*b + 24*c))           for 1 ≤ |x| ≤ 2
       = 0                                              else</code></pre><p>These kernels are continuous, symmetric, have continuous 1st derivatives and sum of coefficients is one (needs not be normalized).  Using the constraint:</p><pre><code class="nohighlight hljs">b + 2*c = 1</code></pre><p>yields a cubic filter with, at least, quadratic order approximation.</p><pre><code class="nohighlight hljs">(b,c) = (1,0)     ==&gt; cubic B-spline
(b,c) = (0, -a)   ==&gt; Keys&#39;s cardinal cubics
(b,c) = (0,1/2)   ==&gt; Catmull-Rom cubics
(b,c) = (b,0)     ==&gt; Duff&#39;s tensioned B-spline
(b,c) = (1/3,1/3) ==&gt; recommended by Mitchell-Netravali</code></pre><p>See paper by [Mitchell and Netravali, <em>&quot;Reconstruction Filters in Computer Graphics Computer Graphics&quot;</em>, Volume <strong>22</strong>, Number 4, (1988)][Mitchell-Netravali-pdf].</p><h2 id="Resampling"><a class="docs-heading-anchor" href="#Resampling">Resampling</a><a id="Resampling-1"></a><a class="docs-heading-anchor-permalink" href="#Resampling" title="Permalink"></a></h2><p>Resampling/interpolation is done by:</p><pre><code class="nohighlight hljs">dst[i] = sum_j ker(grd[j] - pos[i])*src[j]</code></pre><p>with <code>dst</code> the resulting array, <code>src</code> the values of a function sampled on a regular grid <code>grd</code>, <code>ker</code> the interpolation kernel, and <code>pos</code> the coordinates where to interpolate the sampled function.</p><p>To limit the storage and the number of operations, we want to determine the range of indices for which the kernel function is non-zero.  We have that:</p><pre><code class="nohighlight hljs">abs(x) ≥ s/2  ==&gt;  ker(x) = 0</code></pre><p>with <code>s = length(ker)</code>.  Taking <code>x = grd[j] - pos[i]</code>, then:</p><pre><code class="nohighlight hljs">abs(x) &lt; s/2  &lt;==&gt;  pos[i] - s/2 &lt; grd[j] &lt; pos[i] + s/2</code></pre><p><code>grd</code> is a <code>Range</code> so an &quot;exact&quot; formula for its elements is given by a linear interpolation:</p><pre><code class="nohighlight hljs">grd[j] = t0*(j1 - j)/(j1 - j0) + t1*(j - j0)/(j1 - j0)</code></pre><p>with:</p><pre><code class="nohighlight hljs">    j0 = 1             # first grid index
    j1 = length(grd)   # last grid index
    t0 = first(grd)    # first grid coordinate
    t1 = last(grd)     # last grid coordinate</code></pre><p>Note that:</p><pre><code class="nohighlight hljs">    d = (t1 - t0)/(j1 - j0)
      = step(grd)</code></pre><p>is the increment between adjacent grip nodes (may be negative).</p><p>The reverse formula in the form of a linear interpolation is:</p><pre><code class="nohighlight hljs">    f[i] = j0*(t1 - pos[i])/(t1 - t0) + j1*(pos[i] - t0)/(t1 - t0)</code></pre><p>which yields a (fractional) grid index <code>f</code> for coordinate <code>pos[i]</code>.  Taking care of the fact that the grid step may be negative, the maximum number of non-zero coefficients is given by:</p><pre><code class="nohighlight hljs">    M = floor(Int, length(ker)/abs(step(grd)))
      = floor(Int, w)</code></pre><p>with:</p><pre><code class="nohighlight hljs">    w = length(ker)/abs(d)    # beware d = step(grd) may be negative</code></pre><p>the size of the support in grid index units.  The indices of the first non-zero coefficients are:</p><pre><code class="nohighlight hljs">    j = l[i] + k</code></pre><p>for <code>k = 1, 2, ..., M</code> and</p><pre><code class="nohighlight hljs">    l[i] = ceil(Int, f[i] - w/2) - 1</code></pre><p>the corresponding offsets are (assuming the grid extends infinitely):</p><pre><code class="nohighlight hljs">    x[i,j] = pos[i] - grd[j]
           = pos[i] - (grd[0] + (l[i] + k)*d)
           = ((pos[i] - grd[0])/d - l[i] - k)*d
           = (f[i] - l[i] - k)*d</code></pre><p>The final issue to address is to avoid <code>InexactError</code> exceptions.</p><p>[Mitchell-Netravali-pdf]: http://www.cs.utexas.edu/users/fussell/courses/cs384g/lectures/mitchell/Mitchell.pdf</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../library/">« Reference</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.18 on <span class="colophon-date" title="Tuesday 31 May 2022 05:53">Tuesday 31 May 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
